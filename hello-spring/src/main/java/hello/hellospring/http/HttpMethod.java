package hello.hellospring.http;

public class HttpMethod {

    //[HTTP API(Uniform Resource Identifier) 설계]

    // => 요구사항 : 회원 목록 조회 , 회원 조회 , 회원 등록 , 회원 수정 , 회원 삭제
    // => 회원정보 관리 API URI : /read-member-list, /read-member-by-id, /create-member, /update-member, /delete-member
    // => 단순하게 생각하면 위와같이 설계를 할 수 있다. 하지만, 이런 API URI 설계는 가독성은 좋을지 모르지만 좋은 URI 설계는 아니다.
    // => 어째서일까? 설계에서 가장 중요한것은 리소스 식별이다. 그럼 리소스의 의미는 무엇일까?
    // => 회원을 등록하고 수정하고 조회하는 행위를 리소스라 하지 않는다. EX: 수업을 등록해라 → 수업이 리소스 회원이라는 개념 자체가 리소스다.
    // => 리소스를 어떻게 식별하는게 좋을까? 회원을 등록하고 수정하고 조회하는 행위를 모두 배제한다. 회원이라는 리소스만 식별하면 된다.

    //리소스 식별, URI 계층 구조를 활용한 설계
    // => 회원 목록 조회 : /members
    // => 회원 조회: /members/{id}
    // => 회원 등록: /members/{id}
    // => 회원 수정: /members/{id}
    // => 회원 삭제: /members/{id}
    // => 참고로 계층 구조상 상위를 컬렉션으로 보고 복수산어를 사용하기를 권장한다(member → members)
    // => 조회,등록,수정,삭제 URI가 모두 동일한데 어떻게 구분하는가?
    // => 재설계한 URI를 보면 많은 API가 /members/{id} 로 동일하다. 그럼 이를 어떻게 구분해야하는가? HTTP 메서드를 사용하자
    // => 리소스와 행위를 분리하자. URI는 리소스만 식별한다. 리소스와 해당 리소스를 대상으로 하는 행위를 분리한다.
    // => 리소스: 회원
    // => 행위: 조회, 등록, 삭제, 변경
    // => 리소스는 명사, 행위는 동사, 행위(메서드)는 어떻게 구분하는가?  이를 HTTP 메서드를 통해 구분하는데 아래에서 알아보자.

    //HTTP 메서드 종류
    //주요 메서드 : GET, POST, PUT, PATCH, DELETE
    //기타 메서드
    // => HEAD - GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환한다.
    // => OPTIONS - 대상 리소스에 대한 통신 가능 옵션(메소드)을 설명(주로 CORS에서 사용한다)
    // => CONNECT - 대상 자원으로 식별되는 서버에 대한 터널을 설정
    // => TRACE - 대상 리소스에 대한 경로에 따라 메시지 루프백 테스트를 수행

    //GET
    // => 주로 리소스 조회
    // => 예시) 메시지 전달 (HTTP 요청 메시지) - 서버도착 - 리소스 조회 - 응답 데이터 셍성해 전달 (HTTP 응답 메시지 - JSON,HTML, ..다양)
    //HTTP 요청 메시지
    // => GET /members/100 HTTP/1.1
    // => Host: localhost:8080
    //HTTP 응답 메시지
    // => HTTP/1.1 200 OK
    // => Content-Type: application/json
    // => Content-Length: 34
    // =>
    // => {"username": "young", "age": 20}

    //POST
    // => 요청 데이터 처리, 주로 등록에 사용
    // => 서버에서 큰 변화가 필요할 때 이용
    // => 상품주문하면 결제완료가 되는 것이고, 배달시작 버튼을 누르면 서버에서 큰 프로세스가 일어나야 하므로 이럴 때 POST 사용함
    // => 실무에서는 리소스만을 가지고 설계하기 어려울 수도 있음 그럴 때는 컨트롤 URI도 함께 이용해 설계 권장
    // => 조회용으로 메세지 바디에 넣고싶다면 GET은 메세지 바디를 활용하지 않으므로, 그럴 때는 POST 사용함
    // => POST는 메세지에 모든 것을 담아서 사용 가능함. 하지만 조회용으로도 사용하긴 함 언제???? 대용량 프로세스가 진행되어야하거나, 어쩔 수 없는 경우에 사용함
    // => 조회용은 GET으로 이용함 왜? GET이 오면 캐싱하기 때문
    // => 예시) 메세지 전달(HTTP메세지 바디에 등록할 회원 정보를 JSON 형태로 만들어 담음) - 서버도착 - 리소스 등록 - 신규 리소스 생성 - DB에 등록(신규 아이디도 생성) - 응답 데이터
    //HTTP 요청 메시지
    // => POST /members HTTP/1.1
    // => Content-Type: application/json
    // => {"username": "young", "age": 20}
    //HTTP 응답 메시지
    // => Location이라는 헤더 정보로 회원이 생성된 경로를 첨부, 신규회원에 대한 데이터를 바디에 담아서 보내줌
    // => HTTP/1.1 201 Created
    // => Content-Type: application/json
    // => Content-Length: 34
    // => Location: /members/100
    // => {"username": "young", "age": 20}
    // => POST는 요청데이터를 어떻게 처리하는가? 예시
    // => 스펙: POST 메서드는 대상 리소스의 고유한 의미 체계에 따라 포함된 표현을 처리하도록 요청한다.
    // => 예를 들어 POST는 다음과 같은 기능에 사용함
    // => HTML양식에 입력 된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공 ex. HTML, FORM 에 입력한 정보로 회원가입, 주문 등에 사용
    // => 게시판, 뉴스 그룹, 블로그 또는 유사한 기사 그룹에 메시지 게시 ex. 게시판 글쓰기, 댓글 달기
    // => 서버가 아직 식별하지 않은 새 리소스 생성 ex. 신규 주문 생성
    // => 기존 자원에 데이터 추가 ex. 한 문서 끝에 내용 추가
    // => 즉, 이 리소스 URI에 POST 요청이 오면 요청데이터를 어떻게 처리할지 리소스마다 따로 정해야하기에 따로 정해진 것은 없다고 할 수 있다.
    //정리
    // => 새 리소스 생성(등록)할 때 : 서버가 아직 식별하지 않은 새 리소스를 생성 (ex: 회원의 아이디)
    // => 요청 데이터를 처리할 때 : 단순히 데이터를 생성하거나 변경하는 것을 넘어 프로세스를 처리해야 하는 경우 ex) 주문에서 결제완료 → 배달시작 → 배달완료 처럼 단순히 값 변경을 넘어 프로세스의 상태가 변경되는 경우
    // => 요청 데이터를 처리할 때 : POST의 결과로 새로운 리소스가 생성되지 않을수도 있음 ex) [POST] /order/{orderId}/start-delivery (컨트롤 URI) 보면 리소스단위로 설계해야 하는데, 그게 힘든 경우 위처럼 행위가 포함된 URI를 설계할 수도 있다. 이 경우를 컨트롤 URI라 한다.
    // => 다른 메서드로 처리하기 애매할 때 : JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우 애매하면 POST

    //PUT
    // => 리소스 완전히 대체
    // => 리소스가 있을경우 대체하고 없을 경우 생성한다. (Overwrite)
    // => 그럼 POST와 무슨 차이점이 있을까? PUT은 클라이언트가 리소스를 식별한다
    // => PUT은  /members/100 HTTP/1.1  이런 식으로 Location을 알고 있어야 한다.
    // => 업데이트라기보다는 대체이기 때문에, 변경된 내용에 대해서만 부분적 변경하는게 아니기에 아예 덮어씌워진다. 즉, 기존 다른 정보들도 모두 날라간다.
    // => 그럼 이런 덮어쓰기가 아닌 부분 변경을 하고싶다면 어떻게 해야할까? 바로 PATCH를 쓰면 된다.
    // => 예시) 리소스가 있는 경우 : 메시지 전달 (HTTP 요청 메시지) - 서버도착 - 기존 리소스에서 요청 리소스로 대체 - 응답 데이터 (리소스를 완전히 대체)
    // => 예시) 리소스가 없는 경우 : 메시지 전달 (HTTP 요청 메시지) - 서버도착 - 신구 리소스 생성 - 응답 데이터
    //HTTP 요청 메시지
    // => PUT /members/100 HTTP/1.1
    // => Content-Type: application/json
    // => {"username": "old", "age": 50}

    //PATCH
    // => 리소스 부분 변경
    // => PUT과 보내는 양식은 비슷하지만, 서버에서는 PATCH로 전송된 경우 대치가 아닌 필요한 부분만 업데이트 해주는 방식
    // => 예시) 메시지 전달 (HTTP 요청 메시지) - 서버도착 - 기존 리소스에서 요청 리소스로 부분 변경 - 응답 데이터
    //HTTP 요청 메시지
    // => PATCH /members/100 HTTP/1.1
    // => Content-Type: application/json
    // =>
    // => {"username": "old", "age": 50}

    //DELETE
    // => 리소스 제거
    // => 예시) 메시지 전달 (HTTP 요청 메시지) - 서버도착 - 기존 리소스 삭제 - 응답 데이터
    //HTTP 요청 메시지
    // => DELETE /members/100 HTTP/1.1
    // => Host: localhost:8080

    //HTTP 메서드의 속성
    //안전(Safe Methods)
    // => 호출해도 리소스가 변경되지 않는다. GET같은 경우에 조회만해서 리소스를 변경하지 않기에 안전 하다. POST, PUT, DELETE, PATCH 같은 경우 리소스를 변경하기에 안전하지 않다.
    // => 안전의 범위는 해당 리소스만 고려하기에, 외적인 요소까지 고려하지 않는다.
    // => 예를들어 리소스 호출시마다 로그가 남는다 하더라도 리소스에 대한 영향은 아니기에 고려하지 않는다.
    //멱등(Idempotent Methods)
    // => f(f(x)) = f(x)
    // => 메서드를 다 회차 호출하더라도 결과가 동일해야 한다.
    // => GET : 몇 번을 조회하더라도 같은 결과가 조회된다. 회원 정보를 몇번을 조회한다고 정보가 달라지지 않는다.
    // => PUT : 결과를 대체한다. 따라서 같은 요청을 여러번해도 최종 결과는 같다.
    // => DELETE: 결과를 삭제한다. 같은 요청을 여러번 해도 삭제된 결과는 같다.
    // => POST: 멱등이 아니다. 두 번 호출하면 에러가 발생할수 있다. POST로 주문을 두 번 호출하면 결제가 중복될 수 있다.
    // => 어떻게 활용할 수 있을까?
    // => 자동 복구 메커니즘
    // => 서버가 TIMEOUT 등으로 정상 응답을 하지 못했을때 클라이언트에서 같은 요청을 해도 되는가에 대한 판단근거가 된다.
    // => Socket.IO를 통해 소켓 통신을 할때 접속 실패를 하게되면 다시 접속시도를 할 수 있다.
    // => webRTC에서 두 클라이언트간에 SDP 관계 수립후 영상을 송/수신해야할 때 제대로 데이터가 오지않는 경우 다시 negotiation 을 시도한다.
    // => 멱등은 외부 요인으로 인해 리소스가 변경되는 것은 고려하지 않는다. 내가 호출하는 것에 한정한다.
    // => 내가 회원정보를 조회를 다시 할 때 그 사이에 다른 클라이언트의 요청으로 해당 회원정보가 변경되서 조회 결과가 달라지는 것은 고려하지 않는다.
    //캐시가능(Cacheable Methods)
    // => 응답 결과 리소스를 캐시해서 사용해도 될까?
    // => GET, HEAD, POST, PATCH 는 캐시가 가능하다. 하지만, 실제로는 GET, HEAD 정도만 캐시로 사용한다.
    // => POST, PATCH는 본문 내용까지 캐시 키로 고려해야하는데 구현이 쉽지 않다.
    // => GET은 URL만 캐시 키로 관리하면되서 구현이 쉽기에 사용이 편하다.
}
