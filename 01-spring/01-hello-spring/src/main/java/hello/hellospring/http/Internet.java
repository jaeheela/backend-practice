package hello.hellospring.http;

public class Internet {

    //[인터넷 네트워크]
    // 1. 인터넷 통신
    // => 인터넷에서 컴퓨터 둘은 어떻게 통신할까?
    // => 클라이언트에서 다른 클라이언트(컴퓨터)로 데이터를 보낼경우
    // => 위치에따라 위성, 해저광케이블, 기타 통신서버와 같은 노드 들을 거쳐서 상대 클라이언트에 도달한다.
    // => 이렇게 복잡한 과정을거쳐서 어떻게 상대 클라이언트에 찾아갈 수 있는지 알기 위해선 IP(인터넷 프로토콜)에 대해 이해해야 한다.

    // 2. IP(Internet Protocol) - 인터넷 프로토콜
    // => 송신/수신 클라이언트에서 정보를 주고받을 때 사용하는 정보 위주의 프로토콜
    // => 우리가 쇼핑몰에서 물건을 시킬 때 시/군/구 도로명 주소가 필요하듯이 ,방대한 네트워크 세상에서 내가 특정 호스트에 데이터를 보내기 위해서는 주소가 필요한데 이를 IP라 부름
    //IP 역할
    // => 지정한 IP 주소(IP Address)에 데이터 전달
    // => 패킷(Packet)이라는 통신 단위로 데이터 전달 -  IP패킷 규칙 있음
    //IP 패킷 정보
    // => IP패킷(출발IP, 목적IP, 기타) >> 전송 데이터(payload)
    // => 클라이언트 패킷 전달 : 출발IP(100.100.100.1) , 목적IP(200.200.200.2), 전송 데이터(Hello world!)
    // => 서버 패킷 전달 : 출발IP(200.200.200.2), 목적IP(100.100.100.1), 전송 데이터(OK)
    //IP의 한계
    // => 비연결성 : 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송
    // => 비신뢰성 : 중간에 패킷이 사라지면? - 패킷소실,  패킷이 순서대로 안오면? - 용량이 클 경우 끊어서 보냄(최대 1500바이트..?) 그럴 경우 노드를 타고 전송이 되는데 패킷들이 중간에 다른 노드를 탈 수 있음 최종적으로 1→2로 도착해야햐는데 2→1로 도착할 수 있음
    // => 프로그램 구분 : 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면? Ex: 한 컴퓨터에서 게임을 하며 유튜브 뮤직을 듣고있는데, 카톡을 켜놓은 상태

    // 3. TCP, UDP
    //인터넷 프로토콜 스택의 4 계층
    // => [애플리케이션 계층] HTTP, FTP : 무엇인가 비즈니스로직 혹은 특정 제품을 만들어내는 지에 따라 탄생하는 데이터 전송에 대한 약속(규칙) 계층
    // => [전송 계층] TCP, UDP : 물리적으로 연결하고, 경로를 지정했으면 이제 데이터를 전송해야하는데, 데이터를 전송하는 방법을 정의하는 계층
    // => [인터넷 계층] IP : 방대한 인터넷 계층에서 어디로 보낼지 경로를 선택하는 것이 IP게층, 이 자체로는 비연결 지향적이며 신뢰성이 없고 데이터를 전송한 이후 발생하는 문제에 대해서는 신경쓰지 않음
    // => [네트워크 인터페이스 계층] : 물리적인 영역을 표준화 하는 계층으로 실제로 랜선을 꼽는 랜카드나 랜카드 드라이버등이 이에 속함
    //프로토콜 계층
    // => 프로그램에서 Payload 작성 (Hello World!) >> Socket 라이브러리를 통해 전달 >> TCP 정보 생성, 메세지 데이터(Payload)포함 >> IP 패킷 생성, TCP 데이터 포함
    //TCP/IP 패킷 정보
    // => 기존 IP 패킷정보의 한계인 비신뢰성과 비연결성을 TCP 정보를 추가함으로써 한계를 극복
    // => IP패킷(출발IP, 목적IP, 기타) >> TCP 세그먼트(출발PORT, 목적PORT, 전송제어, 순서 검증정보) >> 전송 데이터(payload)
    // TCP 특징
    // => 전송 제어 프로토콜(Transmission Control Protocol)
    // => 1. 연결지향 - TCP 3way handshake(가상 연결)
    // => SYN(Synchronizer) 접속 요청 메세지 전송 >> SYN + ACK 요청 수락 >> ACK (with 데이터 전송 가능) >> 데이터 전송
    // => 참고로 이 상태에서는 개념적으로 연결된 것이지 물리적으로 연결된 것은 아니므로 그 사이의 수많은 노드들과의 연결이 되었는지는 알 수 없다.
    // => 2. 데이터 전달 보증
    // => 클라이언트에서 데이터를 전송하면 서버에서 데이터가 잘 왔는지에 대한 응답을 해줘서 데이터 전달을 보증한다.
    // => 3. 순서 보장
    // => 만약 패킷의 순서가 잘못 도착했을 경우 처리 방법에 따라 다르지만 기본적으로는 잘못 전송된 패킷을 기준으로 다시 보내라고 요청을 해서 다시 패킷을 받는다.
    // => 그럼으로써 순서가 중요한 패킷 데이터에 대해서 순서를 보장할 수 있다. TCP 정보에 PORT부터 순서와 같은 정보들이 포함되어 있기에 가능하다.
    // => 4. 신뢰할 수 있는 프로토콜이지만 UDP보다 전송속도 느림
    // => 5. 현재 대부분 TCP 사용
    //UDP 특징
    // => 사용자 데이터그램 프로토콜(User Datagram Protocol
    // => TCP에 비교해서 기능이 거의 없다.
    // => 연결지향도 아니고, 데이터 전달 보증도 안되고, 순서도 보장되지 않는다.
    // => 하지만, 몹시 단순하기에 속도가 빠르다.
    // => IP와 거의 유사하지만 PORT정보가 포함되어있고 체크섬 정도가 추가되어있다.
    // => 애플리케이션에서 추가적인 작업이 필요하다.

    // 4. PORT
    // => 같은 IP 내에서 프로세스를 구분하는 것  ex) IP(아파트 - 서버) VS 포트(몇동 몇호 - 애플리케이션별 구분)
    // => 만약 패킷이 여러개 전송된다면? ex) 게임 패킷, 화상통화 패킷, 웹브라우저 요청 패킷.. 등등
    // => 내가 해당 IP에 도착하여 해당 서버를 만났을때 이 서버에서 돌아가고 있는 애플리케이션이 2개 이상이라면 이 중 어떤 애플리케이션에 데이터를 전송해야 할까?
    // => TCP/IP 패킷 정보 : [출발IP:출발PORT] , [목적IP:목적PORT], 기타  , 전송제어, 순서 검증정보 , 전송 데이터(payload)
    // => TCP/IP로 보내면 패킷을 보낼 때 출발지IP와 포트를 함께 보내므로 어느 어플리케이션인지 목적지를 다 알 수 있음
    //주요 PORT
    // => 0 ~ 65535 : 할당 가능
    // => 0 ~ 102: 잘 알려진 포트이기에 사용하지 않는 것을 추천 - FTP(20,21) , TELNET(23), HTTP(80), HTTPS(443)

    // 5. DNS
    // => 도메인 네임 시스템(Domain Name System)
    // => 도메인 명을 IP 주소로 변환하는 것 - 일종의 전화번호부
    // => 도메인명을 DNS에서 검색 >> DNS 서버에서는 해당 도메인명의 IP를 알려줌 >> 해당 IP로 접속
    // => 인터넷 통신을 위해 IP(with PORT)가 필요하다고 했는데, 이 IP에는 몇가지 단점이 있다. IP의 단점을 DNS가 해겷해준다.
    // => 가독성이 떨어지고 외우기 힘들다. : 200.200.200.1 , 혹은 174.254.162.74 이런식의 아이피를 모두 외울 수 있을까? 그리고 저런 아이피를 듣고 이게 뭐하는 곳인지 가독성이 떨어진다.
    // => IP는 변경될 수 있다. : 나는 200.200.200.1 로 주소를 기억하고 있는데, 이게 변경되서 200.200.200.3이 된다면 대응하는게 까다롭다.
}
