//1. 데이터 접근 기술 - itemservice-db
// => 시작 : 데이터 접근 기술 진행 방식 소개, 프로젝트 설정, 메모리 저장소, 프로젝트 구조 설명(기본, 설정,테스트), 데이터베이스 테이블 생성
// => 스프링 JdbcTemplate : JdbcTemplate 소개, JdbcTemplate 설정, JdbcTemplate 기본, 동적 쿼리 문제, 구성과 실행, 이름 지정 파라미터, SimpleJdbcInsert
// => 테스트 : 데이터베이스 연동, 데이터베이스 분리, 데이터 롤백, @Transactional, 임베디드 모드 DB, 스프링 부트와 임베디드 모드 정리
// => MyBatis : MyBatis 소개, MyBatis 설정, MyBatis 적용(기본, 설정과 실행, 분석), 기능 정리(동적 쿼리, 기타 기능 정리)
// => JPA : JPA시작, ORM 개념(SQL 중심적인 개발의 문제점, JPA 소개) , JPA설정, JPA 적용(개발,리포지토리 분석,예외 변환)
// => 스프링 데이터 JPA : 소개(등장 이유, 기능) 스프링 데이터 JPA 주요 기능, 스프링 데이터 JPA 적용
// => Querydsl : 소개(기존 방식의 문제점, 해결), Querydsl 설정, Querydsl 적용
// => 활용 방안 : 스프링 데이터 JPA 예제와 트레이드 오프, 실용적인 구조, 다양한 데이터 접근 기술 조합
//2. 스프링 트랜잭션 이해 - springtx
// => 스프링 트랜잭션 전파의 기본 및 활용

//적용 데이터 접근 기술 - 앞으로 실무에서 주로 사용하는 다음과 같은 다양한 데이터 접근 기술들을 학습한다.
//1. SQLMapper : JdbcTemplate, MyBatis,
// => 개발자는 SQL만 작성하면 해당 SQL의 결과를 객체로 편리하게 매핑해준다.
// => JDBC를 직접 사용할 때 발생하는 여러가지 중복을 제거해주고, 기타 개발자에게 여러가지 편리한 기능을 제공한다.
//2. ORM 관련 기술 : JPA, Hibernate, 스프링 데이터 JPA, Querydsl
// => JdbcTemplate이나 MyBatis 같은 SQL 매퍼 기술은 SQL을 개발자가 직접 작성해야 하지만, JPA를 사용하면 기본적인 SQL은 JPA가 대신 작성하고 처리해준다.
// => 개발자는 저장하고 싶은 객체를 마치 자바 컬렉션에 저장하고 조회하듯이 사용하면 ORM 기술이 데이터베이스에 해당 객체를 저장하고 조회해준다.
// => JPA는 자바 진영의 ORM 표준이고, Hibernate(하이버네이트)는 JPA에서 가장 많이 사용하는 구현체이다.
// => 자바에서 ORM을 사용할 때는 JPA 인터페이스를 사용하고, 그 구현체로 하이버네이트를 사용한다고 생각하면 된다.
// => 스프링 데이터 JPA, Querydsl은 JPA를 더 편리하게 사용할 수 있게 도와주는 프로젝트이다.
// -> 실무에서는 JPA를 사용하면 이 프로젝트도 꼭! 함께 사용하는 것이 좋다. 개인적으로는 거의 필수라 생각한다.
// => 궁금한 내용이 많겠지만, 더 자세한 내용은 각각의 기술을 소개하는 장에서 설명하겠다.

//데이터 접근 기술 진행 방식
// => 여기에서 설명하는 데이터 저장 기술들은 하나하나 별도의 책이나 강의로 다루어야 할 정도로 내용이 방대하다.
// => 특히 JPA의 경우 스프링과 학습 분량이 비슷할 정도로 공부해야 할 내용이 많다.
// => 그래서 세세한 기능을 설명하기 보다는 주로 해당 기술이 왜 필요한지, 각 기술의 장단점은 무엇인지 설명하는데 초점을 맞추겠다.
// => 그래서 여러분이 필요할 때 해당 데이터 저장 기술을 스스로 학습할 수 있도록 돕는 것이 이번 장의 목표이다.
// => 정리하면 이번 강의의 목표는 1.데이터 접근 기술에 대한 기본 이해와 전체 큰 그림을 그린다. 2.각 기술들의 핵심 기능 위주로 학습한다. 3.각 기술들을 점진적으로 도입하는 과정을 통해서 각 기술의 특징과 장단점을 자연스럽게 이해할 수 있다.
// => 먼저 메모리 기반으로 완성되어 있는 프로젝트를 확인하고, 이 프로젝트에 데이터 접근 기술을 하나씩 추가해보자.
//프로젝트 설정과 메모리 저장소
// => 스프링 MVC 1편에서 마지막에 완성한 상품 관리 프로젝트를 떠올려보자. 이 프로젝트는 단순히 메모리에 상품 데이터를 저장하도록 되어 있었다.
// => 여기에 메모리가 아닌 실제 데이터 접근 기술들을 하나씩 적용해가면서 각각의 데이터 접근 기술들을 어떻게 사용하는지, 장단점은 무엇인지 코드로 이해하고 학습해보자.
// => MVC1 편에서 개발한 상품 관리 프로젝트를 다듬고 일부 기능을 추가해서 itemservice-db-start 라는 프로젝트에 넣어두었다.
// => 프로젝트 설정 순서 : itemservice-db-start 의 폴더 이름을 itemservice-db 로 변경 >> 프로젝트 임포트 : File Open 해당 프로젝트의 build.gradle 선택 >> Open as Project
// => ItemServiceApplication.main() 을 실행해서 프로젝트가 정상 수행되는지 확인
// => 실행 : http://localhost:8080
// => 참고: 해당 프로젝트는 데이터 접근 기술에 초점을 맞추기 위해 검증을 포함한 여러 기능이 빠져있다
//프로젝트 구조 설명1 - 기본
//제공되는 프로젝트에 대해서 하나씩 알아보자.
//주의 - 스프링 부트 3.0을 선택하게 되면 다음 부분 꼭 확인 - https://bit.ly/springboot3 참고
// => Java 17 이상 사용, javax 패키지 이름을 jakarta로 변경해야함
// => 오라클과 자바 라이센스 문제로 모든 javax 패키지를 jakarta로 변경하기로 했음
// => 패키지 이름 변경의 예) javax.persistence.Entity->jakarta.persistence.Entity(JPA 애노테이션) ,  javax.annotation.PostConstruct -> jakarta.annotation.PostConstruct(@PostConstruct 애노테이션), javax.validation -> jakarta.validation(검증 애노테이션)
// => H2 데이터베이스를 2.1.214 버전 이상 사용
//프로필
// => 스프링은 로딩 시점에 application.properties 의 spring.profiles.active 속성을 읽어서 프로필로 사용한다.
// => 이 프로필은 로컬(나의 PC), 운영 환경, 테스트 실행 등등 다양한 환경에 따라서 다른 설정을 할 때 사용하는 정보이다.
// => 예를 들어서 로컬PC에서는 로컬 PC에 설치된 데이터베이스에 접근해야 하고, 운영 환경에서는 운영 데이터베이스에 접근해야 한다면 서로 설정 정보가 달라야 한다.
// => 심지어 환경에 따라서 다른 스프링 빈을 등록해야 할 수 도 있다. 프로필을 사용하면 이런 문제를 깔끔하게 해결할 수 있다.
//main 프로필
// => [/src/main/resources 하위의 application.properties] : spring.profiles.active=local
// => 이 위치의 application.properties 는 /src/main 하위의 자바 객체를 실행할 때 (주로 main() ) 동작하는 스프링 설정이다.
// => spring.profiles.active=local 이라고 하면 스프링은 local 이라는 프로필로 동작한다.
// => 따라서 직전에 설명한 @Profile("local") 가 동작하고, testDataInit 가 스프링 빈으로 등록된다.
// => 실행하면 The following 1 profile is active: "local"과 로그를 확인할 수 있다.
// => 참고로 프로필을 지정하지 않으면 디폴트( default ) 프로필이 실행된다. - No active profile set, falling back to 1 default profile: "default"
//test 프로필
// => [src/test/resources 하위의 application.properties] : spring.profiles.active=test
// => 이 위치의 application.properties 는 /src/test 하위의 자바 객체를 실행할 때 동작하는 스프링 설정이다.
// => 주로 테스트 케이스를 실행할 때 동작한다. spring.profiles.active=test 로 설정하면 스프링은 test 라는 프로필로 동작한다.
// => 이 경우 직전에 설명한 @Profile("local") 는 프로필 정보가 맞지 않아서 동작하지 않는다. 따라서 testDataInit 이라는 스프링 빈도 등록되지 않고, 초기 데이터도 추가하지 않는다. The following 1 profile is active: "test"
// => 프로필 기능을 사용해서 스프링으로 웹 애플리케이션을 로컬( local )에서 직접 실행할 때는 testDataInit 이 스프링 빈으로 등록된다. 따라서 등록한 초기화 데이터를 편리하게 확인할 수 있다.
// => 초기화 데이터 덕분에 편리한 점도 있지만, 테스트 케이스를 실행할 때는 문제가 될 수 있다. 테스트에서 이런 데이터가 들어있다면 오류가 발생할 수 있다.
// => 예를 들어서 데이터를 하나 저장하고 전체 카운트를 확인하는데 1이 아니라 testDataInit 때문에 데이터가 2건 추가되어서 3이 되는 것이다.
// => 프로필 기능 덕분에 테스트 케이스에서는 test 프로필이 실행된다. 따라서 TestDataInit는 스프링 빈으로 추가되지 않고, 따라서 초기 데이터도 추가되지 않는다.
// => 참고로 프로필에 대한 스프링 부트 공식 메뉴얼은 다음을 참고하자 : https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.profiles
// => 참고로 스프링 프로필에 대한 더 자세한 내용은 다음 출시 예정인 스프링 부트 강의에서 자세히 다룰 예정이다.
//테스트 - 데이터베이스 연동해 테스트
// => 테스트 케이스는 src/test 에 있기 때문에, 실행하면 src/test 에 있는 application.properties 파일이 우선순위를 가지고 실행된다.
// => 그런데 문제는 테스트용 설정에는 spring.datasource.url 과 같은 데이터베이스 연결 설정이 없다는 점이다.
// => 테스트 케이스에서도 데이터베이스에 접속할 수 있게 test의 application.properties 를 다음과 같이 수정하자.
// => [src/test/resources/application.properties 수정]
// => spring.profiles.active=test, spring.datasource.url=jdbc:h2:tcp://localhost/~/test , spring.datasource.username=sa , logging.level.org.springframework.jdbc=debug
//테스트 실행 - 로컬DB
// => src/test/하위의 ItemRepositoryTest 테스트 코드를 확인해보자.

//JdbcTemplate 소개와 설정
// => SQL을 직접 사용하는 경우에 스프링이 제공하는 JdbcTemplate은 아주 좋은 선택지다.
// => JdbcTemplate은 JDBC를 매우 편리하게 사용할 수 있게 도와준다.
// => 장점 : 설정의 편리함 - JdbcTemplate은 spring-jdbc 라이브러리에 포함되어 있는데, 이 라이브러리는 스프링으로 JDBC를 사용할 때 기본으로 사용되는 라이브러리이다. 그리고 별도의 복잡한 설정 없이 바로 사용할 수 있다.
// => 장점 : 반복 문제 해결 - JdbcTemplate은 템플릿 콜백 패턴을 사용해서, JDBC를 직접 사용할 때 발생하는 대부분의 반복 작업을 대신 처리해준다. 개발자는 SQL을 작성하고, 전달할 파리미터를 정의하고, 응답 값을 매핑하기만 하면 된다. 우리가 생각할 수 있는 대부분의 반복 작업을 대신 처리해준다.(커넥션 획득, statement 를 준비하고 실행, 결과를 반복하도록 루프를 실행, 커넥션 종료,statement,resultset종료, 트랜잭션 다루기 위한 커넥션 동기화, 예외 발생시 스프링 예외 변환기 실행)
// => 단점 : 동적 SQL을 해결하기 어렵다.
//JdbcTemplate 데이터베이스 접근 설정
// => [src/main/resources/application.properties] : spring.profiles.active=local , spring.datasource.url=jdbc:h2:tcp://localhost/~/test , spring.datasource.username=sa
// => 이렇게 설정만 하면 스프링 부트가 해당 설정을 사용해서 커넥션 풀과 DataSource , 트랜잭션 매니저를 스프링 빈으로 자동 등록한다. (앞에서 학습한 스프링 부트의 자동 리소스 등록 내용을 떠올려보자.)
// => 주의! 여기서는 src/test 가 아니라 src/main 에 위치한 application.properties 파일을 수정해야 한다!
// => 실행) 실제 DB에 연결해야 하므로 H2 데이터베이스 서버 먼저 실행 >> ItemServiceApplication.main() 실행해서 애플리케이션 서버 실행 >> 웹 브라우저로 http://localhost:8080 에 접속
// => 실행해보면 잘 동작하는 것을 확인할 수 있다. 그리고 DB에 실제 데이터가 저장되는 것도 확인할 수 있다.
// => 참고로 서버를 다시 시작할 때 마다 TestDataInit이 실행되기 때문에 itemA , itemB 도 데이터베이스에 계속 추가된다. 메모리와 다르게 서버가 내려가도 데이터베이스는 유지되기 때문이다.
//JdbcTemplate 로그 추가
// => [src/main/resources/application.properties] : logging.level.org.springframework.jdbc=debug
// => [src/test/resources/application.properties] : logging.level.org.springframework.jdbc=debug
// => JdbcTemplate이 실행하는 SQL 로그를 확인하려면 application.properties 에 다음을 추가하면 된다.
// => main , test 설정이 분리되어 있기 때문에 둘다 확인하려면 두 곳에 모두 추가해야 한다.
//JdbcTemplate 주요 기능
// => JdbcTemplate :순서 기반 파라미터 바인딩을 지원한다.
// => NamedParameterJdbcTemplate : 이름 기반 파라미터 바인딩을 지원한다. (권장)
// => SimpleJdbcInsert : INSERT SQL을 편리하게 사용할 수 있다.
// => SimpleJdbcCall : 스토어드 프로시저를 편리하게 호출할 수 있다.
// => 참고로 스토어드 프로시저를 사용하기 위한 SimpleJdbcCall에 대한 자세한 내용은 다음 스프링 공식 메뉴얼을 참고하자. https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-simple-jdbc-call-1
//JdbcTemplate 사용법 정리
// => JdbcTemplate에 대한 사용법은 스프링 공식 메뉴얼에 자세히 소개되어 있다. 여기서는 스프링 공식 메뉴얼이 제공하는 예제를 통해 JdbcTemplate의 기능을 간단히 정리해보자.
// => 스프링 JdbcTemplate 사용 방법 공식 메뉴얼 : https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-JdbcTemplate
//단건 조회 - 숫자 조회
// => int rowCount = jdbcTemplate.queryForObject("select count(*) from t_actor",Integer.class);
// => 하나의 로우를 조회할 때는 queryForObject() 를 사용하면 된다. 지금처럼 조회 대상이 객체가 아니라 단순 데이터 하나라면 타입을 Integer.class , String.class 와 같이 지정해주면 된다.
//단건 조회 - 숫자 조회, 파라미터 바인딩
// => int countOfActorsNamedJoe = jdbcTemplate.queryForObject("select count(*) from t_actor where first_name = ?", Integer.class,"Joe");
// => 숫자 하나와 파라미터 바인딩 예시이다.
//단건 조회 - 문자 조회
// => String lastName = jdbcTemplate.queryForObject("select last_name from t_actor where id = ?",String.class, 1212L);
// => 문자 하나와 파라미터 바인딩 예시이다.
// 단건 조회 - 객체 조회
// => Actor actor = jdbcTemplate.queryForObject("select first_name, last_name from t_actor where id = ?",(resultSet, rowNum) -> {
// =>	Actor newActor = new Actor(); newActor.setFirstName(resultSet.getString("first_name")); newActor.setLastName(resultSet.getString("last_name"));return newActor;}, 1212L);
// => 객체 하나를 조회한다. 결과를 객체로 매핑해야 하므로 RowMapper를 사용해야 한다. 여기서는 람다를 사용했다.
//목록 조회 - 객체
// => List<Actor> actors = jdbcTemplate.query("select first_name, last_name from t_actor",(resultSet, rowNum) -> {
// =>	Actor actor = new Actor(); actor.setFirstName(resultSet.getString("first_name")); actor.setLastName(resultSet.getString("last_name")); return actor;});
// => 여러 로우를 조회할 때는 query() 를 사용하면 된다. 결과를 리스트로 반환한다. 결과를 객체로 매핑해야 하므로 RowMapper를 사용해야 한다. 여기서는 람다를 사용했다.
//목록 조회 - 객체
// => private final RowMapper<Actor> actorRowMapper = (resultSet, rowNum) -> {
// =>   Actor actor = new Actor(); actor.setFirstName(resultSet.getString("first_name")); actor.setLastName(resultSet.getString("last_name")); return actor;};
// =>   public List<Actor> findAllActors() {return this.jdbcTemplate.query("select first_name, last_name from t_actor",actorRowMapper);}
// => 여러 로우를 조회할 때는 query() 를 사용하면 된다. 결과를 리스트로 반환한다. 여기서는 RowMapper를 분리했다. 이렇게 하면 여러 곳에서 재사용 할 수 있다.
//변경(INSERT, UPDATE, DELETE) : 데이터를 변경할 때는 jdbcTemplate.update()를 사용하면 된다. 참고로 int 반환값을 반환하는데, SQL 실행 결과에 영향받은 로우 수를 반환한다.
//=> 등록 :jdbcTemplate.update("insert into t_actor (first_name, last_name) values (?, ?)","Leonor", "Watling");
//=> 수정 :jdbcTemplate.update("update t_actor set last_name = ? where id = ?","Banjo", 5276L);
//=> 삭제 : jdbcTemplate.update("delete from t_actor where id = ?",Long.valueOf(actorId));
//기타 기능 : 임의의 SQL을 실행할 때는 execute() 를 사용하면 된다. 테이블을 생성하는 DDL에 사용할 수 있다.
// => DDL : jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");
// => 스토어드 프로시저 호출 : jdbcTemplate.update("call SUPPORT.REFRESH_ACTORS_SUMMARY(?)",Long.valueOf(unionId));
//정리
// => 실무에서 가장 간단하고 실용적인 방법으로 SQL을 사용하려면 JdbcTemplate을 사용하면 된다. JPA와 같은 ORM 기술을 사용하면서 동시에 SQL을 직접 작성해야 할 때가 있는데, 그때도 JdbcTemplate을 함께 사용하면 된다.
// => 그런데 JdbcTemplate의 최대 단점이 있는데, 바로 동적 쿼리 문제를 해결하지 못한다는 점이다. 그리고 SQL을 자바 코드로 작성하기 때문에 SQL 라인이 코드를 넘어갈 때 마다 문자 더하기를 해주어야 하는 단점도 있다.
// => 동적 쿼리 문제를 해결하면서 동시에 SQL도 편리하게 작성할 수 있게 도와주는 기술이 바로 MyBatis 이다.
// => 참고로 JOOQ라는 기술도 동적쿼리 문제를 편리하게 해결해주지만 사용자가 많지 않아서 강의에서 다루지는 않는다

//MyBatis 소개와 설정
// => MyBatis는 앞서 설명한 JdbcTemplate보다 더 많은 기능을 제공하는 SQL Mapper이다. 기본적으로 JdbcTemplate이 제공하는 대부분의 기능을 제공한다.
// => JdbcTemplate과 비교해서 MyBatis의 가장 매력적인 점은 SQL을 XML에 편리하게 작성할 수 있고 또 동적 쿼리를 매우 편리하게 작성할 수 있다는 점이다.
// => 먼저 SQL이 여러줄에 걸쳐 있을 때 둘을 비교해보자. MyBatis는 XML에 작성하기 때문에 라인이 길어져도 문자 더하기에 대한 불편함이 없다.
// => JdbcTemplate - SQL 여러줄 : String sql = "update item"+" set item_name=:itemName, price=:price, quantity=:quantity"+" where id=:id";
// => MyBatis - SQL 여러줄 : <update id="update"> update item set item_name=#{itemName},price=#{price},quantity=#{quantity} where id = #{id} </update>
// =>  다음으로 상품을 검색하는 로직을 통해 동적 쿼리를 비교해보자.
// => JdbcTemplate은 자바 코드로 직접 동적 쿼리를 작성해야 한다. 반면에 MyBatis는 동적 쿼리를 매우 편리하게 작성할 수 있는 다양한 기능들을 제공해준다.
// => JdbcTemplate의 설정 장점 : JdbcTemplate은 스프링에 내장된 기능이고, 별도의 설정없이 사용할 수 있다는 장점이 있다.
// => MyBatis의 설정 단점 : 반면에 MyBatis는 약간의 설정이 필요하다.
// => 프로젝트에서 동적 쿼리와 복잡한 쿼리가 많다면 MyBatis를 사용하고, 단순한 쿼리들이 많으면 JdbcTemplate을 선택해서 사용하면 된다. 물론 둘을 함께 사용해도 된다.
// => 하지만 MyBatis를 선택했다면 그것으로 충분할 것이다.
// => 참고로 강의에서는 MyBatis의 기능을 하나하나를 자세하게 다루지는 않는다. MyBatis를 왜 사용하는지, 그리고 주로 사용하는 기능 위주로 다룰 것이다.
// => 그래도 이 강의를 듣고 나면 MyBatis로 개발을 할 수 있게 되고 추가로 필요한 내용을 공식 사이트에서 찾아서 사용할 수 있게 될 것이다.
// => MyBatis는 기능도 단순하고 또 공식 사이트가 한글로 잘 번역되어 있어서 원하는 기능을 편리하게 찾아볼수 있다.
// => MyBatis 공식 사이트 : https://mybatis.org/mybatis-3/ko/index.html
// mybatis 데이터베이스 접근 설정 및 로그 추가
// => [application.properties] 에 다음 설정을 추가하자.
// => [src/main/resources/application.properties] : mybatis.type-aliases-package=hello.itemservice.domain , mybatis.configuration.map-underscore-to-camel-case=true, logging.level.hello.itemservice.repository.mybatis=trace
// => [src/test/resources/application.properties] : mybatis.type-aliases-package=hello.itemservice.domain , mybatis.configuration.map-underscore-to-camel-case=true, logging.level.hello.itemservice.repository.mybatis=trace
// => 주의! 웹 애플리케이션을 실행하는 main , 테스트를 실행하는 test 각 위치의 application.properties를 모두 수정해주어야 한다.
// => mybatis.type-aliases-package : 마이바티스에서 타입 정보를 사용할 때는 패키지 이름을 적어주어야 하는데, 여기에 명시하면 패키지 이름을 생략할 수 있다. 지정한 패키지와 그 하위 패키지가 자동으로 인식된다. 여러 위치를 지정하려면 ,, ;로 구분하면 된다.
// => mybatis.configuration.map-underscore-to-camel-case : JdbcTemplate의 BeanPropertyRowMapper에서 처럼 언더바를 카멜로 자동 변경해주는 기능을 활성화 한다. 바로 다음에 설명하는 관례의 불일치 내용을 참고하자.
// => logging.level.hello.itemservice.repository.mybatis=trace : MyBatis에서 실행되는 쿼리 로그를 확인할 수 있다.
//관례의 불일치
// => 자바 객체에는 주로 카멜( camelCase ) 표기법을 사용한다. itemName 처럼 중간에 낙타 봉이 올라와 있는 표기법이다.
// => 반면에 관계형 데이터베이스에서는 주로 언더스코어를 사용하는 snake_case 표기법을 사용한다. item_name 처럼 중간에 언더스코어를 사용하는 표기법이다.
// => 이렇게 관례로 많이 사용하다 보니 map-underscore-to-camel-case 기능을 활성화 하면 언더스코어 표기법을 카멜로 자동 변환해준다.
// => 따라서 DB에서 select item_name 으로 조회해도 객체의 itemName (setItemName()) 속성에 값이 정상 입력된다.
// => 정리하면 해당 옵션을 켜면 snake_case 는 자동으로 해결되니 그냥 두면 되고, 컬럼 이름과 객체 이름이 완전히 다른 경우에는 조회 SQL에서 별칭을 사용하면 된다.
// => 예) DB:select item_name , 객체:name -> [별칭을 통한 해결방안] select item_name as name




//JPA 소개와 설정
//JPA 데이터베이스 접근 설정
//JPA 로그 추가



plugins {
	id 'org.springframework.boot' version '2.6.5'
	id 'io.spring.dependency-management' version '1.0.11.RELEASE'
	id 'java'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '11'

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}

repositories {
	mavenCentral()
}

// spring-boot-starter-thymeleaf : 타임리프 사용
// spring-boot-starter-web : 스프링 웹, MVC 기능 사용
// lombok : lombok을 추가로 테스트에서도 사용하는 설정 주의
// spring-boot-starter-test : 스프링이 제공하는 테스트 기능

// JdbcTemplate 사용하기 위한 라이브러리 추가
// => org.springframework.boot:spring-boot-starter-jdbc 를 추가하면 JdbcTemplate이 들어있는 spring-jdbc 가 라이브러리에 포함된다.
// => 여기서는 H2 데이터베이스에 접속해야 하기 때문에 H2 데이터베이스의 클라이언트 라이브러리(Jdbc Driver)도 추가하자. : runtimeOnly 'com.h2database:h2'
// => JdbcTemplate은 spring-jdbc 라이브러리만 추가하면 된다. 별도의 추가 설정 과정은 없다

// MyBatis 사용하기 위한 라이브러리 추가
// => mybatis-spring-boot-starter 라이브러리를 사용하면 MyBatis를 스프링과 통합하고, 설정도 아주 간단히 할 수 있다.
// => mybatis-spring-boot-starter 라이브러리를 사용해서 간단히 설정하는 방법을 알아보자.
// => implementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter:2.2.0'
// => 참고로 뒤에 버전 정보가 붙는 이유는 스프링 부트가 버전을 관리해주는 공식 라이브러리가 아니기 때문이다.
// => 스프링 부트가 버전을 관리해주는 경우 버전 정보를 붙이지 않아도 최적의 버전을 자동으로 찾아준다.
// => 참고로 스프링 부트 3.0 이상을 사용한다면 mybatis-spring-boot-starter 버전을 2.2.0 대신에 3.0.1을 사용해야 한다.
// => mybatis-spring-boot-starter : MyBatis를 스프링 부트에서 편리하게 사용할 수 있게 시작하는 라이브러리
// => mybatis-spring-boot-autoconfigure : MyBatis와 스프링 부트 설정 라이브러리
// => mybatis-spring : MyBatis와 스프링을 연동하는 라이브러리
// => mybatis : MyBatis 라이브러리

dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
	implementation 'org.springframework.boot:spring-boot-starter-web'

	//JdbcTemplate 추가
	implementation 'org.springframework.boot:spring-boot-starter-jdbc'
	//MyBatis 추가
	implementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter:2.2.0'
	//H2 데이터베이스 추가
	runtimeOnly 'com.h2database:h2'

	compileOnly 'org.projectlombok:lombok'
	annotationProcessor 'org.projectlombok:lombok'

	//테스트에서 사용
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testCompileOnly 'org.projectlombok:lombok'
	testAnnotationProcessor 'org.projectlombok:lombok'
}

tasks.named('test') {
	useJUnitPlatform()
}
