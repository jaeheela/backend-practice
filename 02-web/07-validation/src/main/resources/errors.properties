#required.item.itemName=상품 이름은 필수입니다.
#range.item.price=가격은 {0} ~ {1} 까지 허용합니다.
#max.item.quantity=수량은 최대 {0} 까지 허용합니다.
#totalPriceMin=가격 * 수량의 합은 {0}원 이상이어야 합니다. 현재 값 = {1}

# 오류 코드와 메시지 처리3
# => 오류 코드를 만들 때 자세히 만들 수도 있고, - [required.item.itemName : 상품 이름은 필수 입니다. range.item.price : 상품의 가격 범위 오류 입니다.]
# => 또는 다음과 같이 단순하게 만들 수도 있다.  - [required : 필수 값 입니다. range : 범위 오류 입니다.]
# => 단순하게 만들면 범용성이 좋아서 여러곳에서 사용할 수 있지만, 메시지를 세밀하게 작성하기 어렵다.
# => 반대로 너무 자세하게 만들면 범용성이 떨어진다.
# => 가장 좋은 방법은 범용성으로 사용하다가, 세밀하게 작성해야 하는 경우에는 세밀한 내용이 적용되도록 메시지에 단계를 두는 방법이다.
# => 예를 들어서 required 라고 오류 코드를 사용한다고 가정해보자. 다음과 같이 required 라는 메시지만 있으면 이 메시지를 선택해서 사용하는 것이다.

# [required: 필수 값 입니다.]
# => 그런데 오류 메시지에 required.item.itemName 와 같이 객체명과 필드명을 조합한 세밀한 메시지 코드가 있으면 이 메시지를 높은 우선순위로 사용하는 것이다.

# [#Level1 required.item.itemName: 상품 이름은 필수 입니다.[ [#Level2required: 필수 값 입니다.]
# => 물론 이렇게 객체명과 필드명을 조합한 메시지가 있는지 우선 확인하고, 없으면 좀 더 범용적인 메시지를 선택하도록 추가 개발을 해야겠지만,
# => 범용성 있게 잘 개발해두면, 메시지의 추가 만으로 매우 편리하게 오류 메시지를 관리할 수 있을 것이다.
# => 스프링은 MessageCodesResolver 라는 것으로 이러한 기능을 지원한다.

# 오류 코드와 메시지 처리4
# => 우선 테스트 코드로 MessageCodesResolver를 알아보자. - MessageCodesResolverTest.java

# 오류 코드와 메시지 처리5
# => 오류 코드 관리 전략 : 핵심은 구체적인 것에서! 덜 구체적인 것으로!
# => MessageCodesResolver 는 required.item.itemName 처럼 구체적인 것을 먼저 만들어주고, required 처럼 덜 구체적인 것을 가장 나중에 만든다.
# => 이렇게 하면 앞서 말한 것 처럼 메시지와 관련된 공통 전략을 편리하게 도입할 수 있다.
# => 왜 이렇게 복잡하게 사용하는가? 모든 오류 코드에 대해서 메시지를 각각 다 정의하면 개발자 입장에서 관리하기 너무 힘들다.
# => 크게 중요하지 않은 메시지는 범용성 있는 requried 같은 메시지로 끝내고, 정말 중요한 메시지는 꼭 필요할 때 구체적으로 적어서 사용하는 방식이 더 효과적이다.
# => 이제 우리 애플리케이션에 이런 오류 코드 전략을 도입해보자 우선 다음처럼 만들어보자.

#==ObjectError==
#Level1 - 매우 디테일하게
totalPriceMin.item=상품의 가격 * 수량의 합은 {0}원 이상이어야 합니다. 현재 값 = {1}
#Level2 - 생략
totalPriceMin=전체 가격은 {0}원 이상이어야 합니다. 현재 값 = {1}

#==FieldError==
#Level1 - 매우 디테일하게
required.item.itemName=상품 이름은 필수입니다.
range.item.price=가격은 {0} ~ {1} 까지 허용합니다.
max.item.quantity=수량은 최대 {0} 까지 허용합니다.

#Level2 - 생략

#Level3
required.java.lang.String = 필수 문자입니다.
required.java.lang.Integer = 필수 숫자입니다.
min.java.lang.String = {0} 이상의 문자를 입력해주세요.
min.java.lang.Integer = {0} 이상의 숫자를 입력해주세요.
range.java.lang.String = {0} ~ {1} 까지의 문자를 입력해주세요.
range.java.lang.Integer = {0} ~ {1} 까지의 숫자를 입력해주세요.
max.java.lang.String = {0} 까지의 숫자를 허용합니다.
max.java.lang.Integer = {0} 까지의 숫자를 허용합니다.

#Level4
required = 필수 값 입니다.
min= {0} 이상이어야 합니다.
range= {0} ~ {1} 범위를 허용합니다.
max= {0} 까지 허용합니다.

# => 크게 객체 오류와 필드 오류를 나누었다.
# => 그리고 범용성에 따라 레벨을 나누어두었다.
# => itemName 의 경우 required 검증 오류 메시지가 발생하면 다음 코드 순서대로 메시지가 생성된다.
# => required.item.itemName >> required.itemName >> required.java.lang.String >> required
# => 그리고 이렇게 생성된 메시지 코드를 기반으로 순서대로 MessageSource 에서 메시지에서 찾는다.
# => 구체적인 것에서 덜 구체적인 순서대로 찾는다. 메시지에 1번이 없으면 2번을 찾고, 2번이 없으면 3번을 찾는다.
# => 이렇게 되면 만약에 크게 중요하지 않은 오류 메시지는 기존에 정의된 것을 그냥 재활용 하면 된다!
# 실행
# => Level1 전부 주석해보자 >> Level2,3 전부 주석해보자 >> Level4 전부 주석해보자
# => 못찾으면 코드에 작성한 디폴트 메시지를 사용한다.
# => Object 오류도 Level1, Level2로 재활용 가능하다.




# 오류 코드와 메시지 처리6
# => 스프링이 직접 만든 오류 메시지 처리
# => 검증 오류 코드는 다음과 같이 2가지로 나눌 수 있다.
# => 1. 개발자가 직접 설정한 오류 코드 -> rejectValue() 를 직접 호출
# => 2. 스프링이 직접 검증 오류에 추가한 경우(주로 타입 정보가 맞지 않음)

# => 지금까지 학습한 메시지 코드 전략의 강점을 지금부터 확인해보자.
# => price 필드에 문자 "A"를 입력해보자.
# => 로그를 확인해보면 BindingResult 에 FieldError 가 담겨있고, 다음과 같은 메시지 코드들이 생성된 것을 확인할 수 있다.
# => codes[typeMismatch.item.price,typeMismatch.price,typeMismatch.java.lang.Integer,typeMismatch]
# => 다음과 같이 4가지 메시지 코드가 입력되어 있다.
# => typeMismatch.item.price
# => typeMismatch.price
# => typeMismatch.java.lang.Integer
# => typeMismatch
# => 그렇다. 스프링은 타입 오류가 발생하면 typeMismatch 라는 오류 코드를 사용한다.
# => 이 오류 코드가 MessageCodesResolver 를 통하면서 4가지 메시지 코드가 생성된 것이다.
# => 실행해보자. 아직 errors.properties 에 메시지 코드가 없기 때문에 스프링이 생성한 기본 메시지가 출력된다.
# => Failed to convert property value of type java.lang.String to required type java.lang.Integer for property price; nested exception is java.lang.NumberFormatException: For input string: "A"
# => error.properties 에 다음 내용을 추가하자
# => typeMismatch.java.lang.Integer=숫자를 입력해주세요.
# => typeMismatch=타입 오류입니다.
# => 다시 실행해보자. 결과적으로 소스코드를 하나도 건들지 않고, 원하는 메시지를 단계별로 설정할 수 있다.
# 정리
# => 메시지 코드 생성 전략은 그냥 만들어진 것이 아니다.
# => 조금 뒤에서 Bean Validation을 학습하면 그 진가를 더 확인할 수 있다.
#추가
typeMismatch.java.lang.Integer=숫자를 입력해주세요.
typeMismatch=타입 오류입니다.






#Bean Validation 추가

#NotBlank.item.itemName=상품 이름을 적어주세요.

#NotBlank={0} 공백X
Range={0}, {2} ~ {1} 허용
Max={0}, 최대 {1}
